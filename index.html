<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Curso JS</title>
</head>

<body>
    <h1>32 conceitos que todo desenvolvedor JavaScript deveria saber</h1>

    <h2>Pilha de chamadas (FIFO e LIFO)</h2>

    <p><strong>FIFO</strong> = firts in first out - o primeiro que entrou √© o primeiro a sair</p>
    <p><strong>LIFO</strong> = Last in first out - o ultimo a entrar √© o primeiro a sair </p>
    <p><strong>(JS normalmente √© LIFO)</strong></p>

    <script>
        // function funcao1() {
        //     funcao2();
        //     console.log('executou a fun√ß√£o 1')
        // }

        // function funcao2() {
        //     funcao3();
        //     console.log('executou a fun√ß√£o 2')
        // }

        // function funcao3() {
        //     console.log('executou a fun√ß√£o 3')
        // }

        // funcao1();
    </script>

    <hr>

    <h2>Tipos primitivos</h2>
    <p>JavaScript tem 7 tipos primitivos:</p>
    <ul>
        <li><strong>string</strong> - texto</li>
        <li><strong>number</strong> - n√∫mero</li>
        <li><strong>boolean</strong> - verdadeiro ou falso</li>
        <li><strong>undefined</strong> - indefinido</li>
        <li><strong>undefined</strong> - nulo</li>
        <li><strong>symbol</strong> - criar valores, fun√ß√µes privadas e at√© mesmo para interceptar um comportamento
            padr√£o de um objeto no JavaScript.</li>
        <li><strong>bigint</strong> - n√∫meros muito grandes</li>
    </ul>

    <script>
        // console.log(typeof true); //Boolean
        // console.log(typeof Boolean(true)); //Boolean
        // console.log(typeof new Boolean(true)); //Object
        // console.log(typeof (new Boolean(true)).valueOf()); //Boolean
        // console.log(typeof 'Amanda'); //string
        // console.log(typeof 21); //number
        // console.log('Amanda'.length);

        // let doze = new Number(12);
        // let quinze = doze + 3;
        // console.log(quinze);

        // console.log(typeof doze); //object
        // console.log(typeof quinze); //number
    </script>

    <hr>

    <h2>Tipos de valores e tipos de refer√™ncias</h2>

    <p>Primitivos ‚Üí Copiados por VALOR</p>

    <p>Cada vari√°vel guarda seu pr√≥prio valor. <br>
        N√£o existe liga√ß√£o entre elas. <br>
        Alterar uma n√£o altera a outra. <br>
        <strong>Isso √© c√≥pia por valor.</strong>
    </p>

    <script>
        // Quando voc√™ faz:
        // let c = 10;
        // let b = c;

        // O que acontece na mem√≥ria ?
        // c ‚Üí 10
        // b ‚Üí 10(c√≥pia independente)

        // b = 20;

        // Depois:

        // b ‚Üí 20
        // c ‚Üí 10 (n√£o muda)

        // console.log(c); // 10
    </script>

    <p>Refer√™ncia ‚Üí Copiados por REFER√äNCIA</p>
    <p>
        Objetos { } <br>
        Arrays [ ] <br>
        Fun√ß√µes function()
    </p>

    <script>
        // console.log(x, y); //20 10

        // let x =  {valor: 10 };
        // let y = x;
        // x.valor = 20;

        // console.log(x, y); //20 20

        // Agora o que acontece na mem√≥ria?

        // x ‚Üí endere√ßo 0x001
        // y ‚Üí endere√ßo 0x001

        // Ambos apontam para o mesmo objeto na mem√≥ria.

        // Quando voc√™ altera:

        // x.valor = 20;

        // Voc√™ n√£o est√° mudando x.
        // Voc√™ est√° mudando o conte√∫do do endere√ßo 0x001.

        // Como y tamb√©m aponta para esse mesmo endere√ßo‚Ä¶

    </script>

    <script>
        // let obj1 = { nome: "Amanda" };
        // let obj2 = obj1;

        // obj2.nome = "Maria";

        // console.log(obj1.nome); // Maria

        // Porque agora voc√™ mudou a refer√™ncia, n√£o o conte√∫do.

        // Antes:

        // obj1 ‚Üí 0x001
        // obj2 ‚Üí 0x001

        // Depois:

        // obj2 ‚Üí 0x002
        // obj1 ‚Üí 0x001

        // S√£o objetos diferentes agora.
    </script>

    <script>
        // Compara√ß√£o direta
        // let a = 10;
        // let b = 10;

        // console.log(a === b); // true

        // Primitivos com mesmo valor ‚Üí iguais.

        // Agora:

        // let obj1 = { nome: "Amanda" };
        // let obj2 = { nome: "Amanda" };

        // console.log(obj1 === obj2); // false

        // Mesmo conte√∫do.
        // Mas refer√™ncias diferentes.
    </script>

    <hr>

    <h2>COER√á√ÉO - Impl√≠cito, Explicito e chamada de m√©todos</h2>

    <p>Coer√ß√£o de tipo √© quando o JavaScript converte automaticamente (ou voc√™ for√ßa) um valor de um tipo para outro.
    </p>

    <p>Coer√ß√£o Impl√≠cita (autom√°tica) - O JavaScript decide converter sozinho.</p>

    <p>Quando existe + e um dos lados √© string ‚Üí o JS converte tudo para string.</p>

    <p>O operador - s√≥ funciona com n√∫mero.</p>

    <script>
        // "5" + 1 // "51"
        // "5" - 1 // 4
    </script>

    <script>
        // console.log('5' - 5); // 0
        // console.log('5' + 5); // "55"
        // console.log(true + 1); // 2
        // console.log(true + true); // 2
    </script>

    <script>
        // console.log([] + {}); //"[object Object]"
    </script>

    <p>
        O que acontece? <br>
        [] vira "" <br>
        {} vira "[object Object]" <br>
        String + string ‚Üí concatena
    </p>

    <p>Operadores que for√ßam coer√ß√£o impl√≠cita</p>

    <p>Unary Plus</p>

    <p>Equivalente a: Number('5')</p>

    <p>String vazia</p>

    <p>console.log(5 + ''); // "5"</p>

    <p>Operadores l√≥gicos</p>

    <p>console.log(123 && 'oi'); // "oi"</p>

    <p>
        && retorna o √∫ltimo valor verdadeiro. <br>
        123 √© truthy <br>
        Ent√£o retorna 'oi'
    </p>

    <p>console.log(null || true); // true</p>

    <p>null √© falsy.
        Ent√£o retorna o pr√≥ximo valor.</p>

    <script>
        // console.log(+'5'); // 5
    </script>

    <p>Coer√ß√£o Expl√≠cita (voc√™ controla) - Aqui voc√™ decide converter.</p>

    <p>Converter para n√∫mero</p>

    <script>
        // Number('50') // 50
        // parseInt('50')
        // parseFloat('50.5')
    </script>

    <p>Converter para string</p>

    <script>
        // String(50)
        //     (50).toString()
    </script>

    <script>
        // Number("5")
        // String(10)
        // Boolean(0)
    </script>

    <p>Converter para boolean</p>

    <script>
        // Boolean(0) // false
        // Boolean(1) // true
        // Boolean("") // false
        // Boolean("Amanda") // true
    </script>

    <p>Existem apenas 7 valores falsy:</p>

    <p>false <br>
        0 <br>
        -0 <br>
        "" <br>
        null <br>
        undefined <br>
        NaN</p>

    <p>Chamada de m√©todos</p>

    <p>EX. "amanda".toUpperCase() -> O JS cria temporariamente um objeto String wrapper.</p>
    <p>JS cria objeto tempor√°rio</p>

    <script>
        // let nome = "Amanda";
        // nome.length;

        // new String("amanda")
    </script>

    <script>
        // console.log('5' - 5);
        // console.log('5' + 5);
        // console.log(true + 1);
        // console.log(true + true);
        // console.log([] + {});
        // console.log([] + []);

        // IMPLICITO
        // console.log(+'5');
        // console.log(5 + '');
        // console.log(123 && 'oi');
        // console.log( null || true);

        // EXPLICITO
        // console.log(Number('50'));
        // console.log(String(50));
    </script>

    <hr>

    <h2>==, === e typeof</h2>

    <p>== (igualdade abstrata)</p>

    <p>O == permite coer√ß√£o de tipo antes de comparar.</p>

    <p>null == undefined, se for, ele retorna true</p>
    <p>number == string, se for, ele vai converter a string em numero</p>
    <p>boolean == number, se for, ele converte o boolean em numero</p>
    <p>boolean == string, se for, ele converte o string em boolean</p>
    <p><small>
            <p>Na verdade o JS converte boolean em n√∫mero primeiro, depois compara.</p>
        </small></p>
    <p>objeto == primitivo, se for, ele converte o objeto em string</p>

    <script>
        // null == undefined // true
        // null === undefined // false

        // 3 == '3' // true

        // true == 1 // true
        // false == 0 // true

        // true == "1"

        // [1] == 1 // true
        // // [1].toString() ‚Üí "1"
        // // Number("1") ‚Üí 1

        // [] == false // true
    </script>

    <script>
        // console.log(3 == '3');
        // console.log(3 === 3);
    </script>

    <p>=== (igualdade estrita)</p>

    <p>Aqui N√ÉO existe coer√ß√£o.</p>

    <p>Ele compara:
        Tipo e
        Valor</p>

    <script>
        // 3 === '3' // false
        // 3 === 3   // true
    </script>

    <p>typeof - Usado para descobrir o tipo.</p>

    <script>
        // typeof 10        // "number"
        // typeof "Amanda"  // "string"
        // typeof true      // "boolean"
        // typeof undefined // "undefined"
        // typeof Symbol()  // "symbol"
        // typeof 10n       // "bigint"
    </script>

    <p>Isso √© um BUG hist√≥rico do JavaScript. null n√£o √© objeto.</p>

    <script>
        typeof null // "object"
    </script>

    <script>
        // typeof {}          // "object"
        // typeof []          // "object"
        // typeof function () { } // "function"
    </script>

    <hr>

    <h2>Escopo global, de fun√ß√£o, de bloco e l√©xico</h2>

    <p>Escopo global: Vari√°veis declaradas fora de qualquer fun√ß√£o/bloco.</p>
    <p>Problema: Podem ser sobrescritas, Poluem o escopo global e Em sistemas grandes isso vira caos</p>
    <p>Escopo de bloco/fun√ß√£o: Criado com function.</p>
    <p>
        Function cria escopo de fun√ß√£o <br>
        Bloco ({}) cria escopo de bloco quando usamos let e const
    </p>

    <p>Escopo l√©xico: A vari√°vel √© resolvida com base onde foi declarada, n√£o onde foi chamada.</p>
    <script>
        // let nome = "Amanda";

        // function externa() {
        //     let sobrenome = "Ambrosio";

        //     function interna() {
        //         console.log(nome);
        //         console.log(sobrenome);
        //     }

        //     interna();
        // }

        // externa();
    </script>

    <script>
        // var nome = "Amanda";

        // function teste() {
        //     var variavel = "meu nome";
        //     function teste2() {
        //         variavel = "meu nome";
        //     }
        // } //erro

        // teste();

        // var a = 0;

        // function alterar() {
        //     a = 10;
        // }

        // console.log(a);
        // alterar();
        // console.log(a);
    </script>

    <p>
        <strong>O que √© Hoisting?</strong> <br>
        Durante a fase de cria√ß√£o do c√≥digo, o JavaScript: <br>
        Move declara√ß√µes para o topo do escopo <br>
        N√ÉO move inicializa√ß√µes
    </p>

    <script>
        // console.log(a);
        // var a = 10; //undefined
    </script>

    <p>Porque existe algo chamado:

        üëâ Temporal Dead Zone (TDZ)</p>

    <p>A vari√°vel existe, mas n√£o pode ser acessada antes da declara√ß√£o.</p>

    <script>
        // console.log(b);
        // let b = 20; //ReferenceError
    </script>

    <p>Conceito -> O que faz</p>

    <p>Global -> Vari√°vel acess√≠vel em todo c√≥digo</p>

    <p>Fun√ß√£o -> Criado por function</p>

    <p>Bloco -> Criado por {} com let/const</p>

    <p>L√©xico -> Resolvido onde foi declarado</p>

    <p>Hoisting -> Declara√ß√µes s√£o movidas para o topo</p>

    <hr>

    <h2>Express√£o e declara√ß√£o</h2>

    <p>Express√£o vs Declara√ß√£o impacta: <br>
        Hoisting <br>
        Fun√ß√µes <br>
        Arrow functions <br>
        IIFE <br>
        Callbacks <br>
        React <br>
        Programa√ß√£o funcional</p>

    <p><strong>O que √© uma Express√£o?</strong></p>

    <p>Express√£o √© qualquer coisa que produz um valor.</p>

    <script>
        // 2 + 2
        // "a" + "b"
        // true
        // Math.random()
    </script>

    <p><strong>O que √© uma Declara√ß√£o (Statement)?</strong></p>

    <p>√â uma instru√ß√£o que executa algo.</p>

    <script>
        // if (true) { }
        // for (...) { }
        // while (...) { }
        // var x = 10;
        // function teste() { }
    </script>

    <p>Voc√™ n√£o pode fazer:</p>

    <script>
        // let x = if (true) { 10 };
    </script>

    <p>Em programa√ß√£o, express√µes s√£o trechos de c√≥digo que retornam um valor (como 2 + 2), enquanto declara√ß√µes
        (statements) s√£o instru√ß√µes que realizam a√ß√µes ou alteram o estado do programa (como if, for ou int x;). </p>

    <p>Express√µes produzem valores e s√£o blocos de constru√ß√£o, j√° declara√ß√µes executam comandos, sem necessariamente
        retornar algo.</p>

    <script>
        // console.log(1 + 1);
        // console.log(Math.random() + 5); //express√£o

        // function expressao () {
        //     return 1 + 1;
        // }

        // console.log(expressao());

        // var variavel = 20;

        // if (true) {
        //     variavel = 30;
        // }

        // function soma (a) {
        //     return a + 10;
        // }

        // console.log(Math.random());
    </script>

    <hr>

    <h2>IIFE e Namespaces</h2>

    <p>Immediately Invoked Function Expression -> Express√£o de fun√ß√£o imediatamente invocada</p>

    <p>IIFE + Namespaces s√£o a base da organiza√ß√£o de c√≥digo antes de import/export.</p>

    <p>Antes de existir let, const e modules, tudo era var (escopo global ou de fun√ß√£o). Ent√£o IIFE era usada para
        evitar poluir o escopo global.</p>

    <script>
        // function alerta() {
        //     alert("Ol√° mundo!")
        // }

        // const alerta = function() {
        //     alert("Ol√° mundo!")
        // }

        // alerta();

        // !function() { //Pemite uma fun√ß√£o sem o nome
        //     alert("Ol√° mundo!")
        // }(); //IIFE - fun√ß√£o s√≥ pode ser executada apenas uma vez

        // (function(){
        //     alert('Ol√°!');
        // })
    </script>

    <script>
        // var dados = (function() {
        //     var contador = 0;
        //     return {
        //         incrementar: function() {
        //             contador = contador + 1;
        //             return contador;
        //         }
        //     }
        // }());

        // console.log(dados.incrementar());
        // console.log(dados.contador);
    </script>

    <p>
        O que est√° acontecendo? <br>

        A IIFE executa imediatamente. <br>

        Cria vari√°vel privada contador. <br>

        Retorna um objeto. <br>

        Esse objeto √© armazenado em dados.
    </p>

    <script>
        // console.log(dados.incrementar()); // 1
        // console.log(dados.incrementar()); // 2

        // console.log(dados.contador); // undefined
    </script>

    <p>Porque contador est√° no escopo interno da fun√ß√£o.</p>

    <p>Isso √©: <br>

        üëâ Encapsulamento <br>
        üëâ Closure <br>
        üëâ Vari√°vel privada
    </p>

    <p>uma fun√ß√£o criada dentro de um objeto √© um metodo</p>

    <p>contador esta como uma variavel privada</p>

    <p>Namespace evita conflito porque organiza fun√ß√µes dentro de um objeto espec√≠fico, n√£o porque est√° em escopo de
        bloco. Escopo de bloco n√£o impede conflito global se algo for exportado ou declarado globalmente.</p>

    <hr>

    <h2>M√≥dulos</h2>

    <p>arquivos index.js e utilitarios.js</p>

    <hr>

    <h2>Fila de eventos e Pilha de eventos</h2>

    <p>JS √© uma linguagem ass√≠ncrona e Single Thread</p>

    <p>Single Thread -> Ele executa uma coisa por vez e Possui uma √∫nica Call Stack (Pilha de Execu√ß√£o)</p>

    <p>
        Call Stack (Pilha de Eventos) -> Funciona como uma pilha de pratos. √öltimo que entra √© o primeiro que sai (LIFO)
    </p>

    <p>
        Event Queue (Fila de Eventos) -> √â onde ficam as tarefas ass√≠ncronas esperando para executar.
        <br>
        Funciona como fila de banco: Primeiro que entra √© o primeiro que sai (FIFO)
    </p>

    <p>
        Event Loop <br>
        Verifica se a Call Stack est√° vazia
        <br>
        Se estiver vazia, pega algo da Event Queue
        <br>
        Coloca na Call Stack
        <br>
        Ele fica fazendo isso o tempo todo.
    </p>

    <p>
        Assincrono - callback ou promisses
    </p>

    <p>event loop</p>

    <p>event queue</p>

    <script>
        // function loopEventos() {
        //     console.log('a');
        //     for (let i = 1; i <= 4; i++) {
        //         console.log('b - ' + i);
        //     }
        //     console.log('c');
        //     setTimeout(() => {
        //         console.log('d');
        //     }, 0);
        //     console.log('e');
        // }

        // loopEventos();
    </script>

    <p>
        setTimeout(..., 0) -> Mesmo com 0 milissegundos. A fun√ß√£o N√ÉO vai direto para a Call Stack. Ela vai para a Web
        API (ambiente do navegador). Depois √© enviada para a Event Queue. <br>
        Ela s√≥ executa quando Call Stack estiver vazia e Event Loop pegar da fila
    </p>

    <p>
        Microtasks vs Macrotasks (n√≠vel mais profundo)
    </p>

    <p>Macrotask Queue
        (setTimeout,
        setInterval,
        setImmediate,
        eventos DOM)</p>

    <p>
        Microtask Queue
        (Promise.then,
        async/await,
        queueMicrotask)
    </p>

    <p>Microtasks t√™m prioridade.</p>

    <hr>

    <h2>SetTimeOut, SetInterval, requestAnimationFrame</h2>

    <p>
        setTimeout -> Executa uma fun√ß√£o uma √∫nica vez depois de um tempo m√≠nimo. (Ele entra na Macrotask Queue e S√≥
        executa quando a Call Stack estiver vazia.)
    </p>

    <p>
        setInterval -> Executa repetidamente.
    </p>

    <p>Ele n√£o espera a execu√ß√£o terminar. Se o callback demorar mais que o intervalo Pode acumular execu√ß√£o e Pode
        gerar bug ou travamento</p>

    <p>
        requestAnimationFrame -> Ele √© feito para anima√ß√£o. Executa a fun√ß√£o antes da pr√≥xima repaint do navegador. 60
        vezes por segundo (60fps)
    </p>

    <script>
        // setTimeout(() => {
        //     alert("SetTimeOut");
        // }, 2000);

        // const mostraAlerta = () => {
        //     alert("SetTimeOut");
        // };
        // setTimeout(mostraAlerta, 2000);

        // const mostraAlertaNome = (nome) => {
        //     alert("SetTimeOut - " + nome);
        // };
        // setTimeout(mostraAlertaNome, 2000, "Amanda");

        // const mostraAlertaNome = (nome) => {
        //     alert("SetTimeOut - " + nome);
        // };
        // setTimeout(mostraAlertaNome, 2000, "Amanda");

        // const timeout = setTimeout(mostraAlertaNome, 3500, "Amanda");

        // setTimeout(() => {
        //     clearTimeout(timeout);
        // }, 1500);
    </script>

    <script>
        // const interval = setInterval(() => {
        //     console.log("Teste");
        // }, 1000);

        // setInterval(() => {
        //     clearInterval(interval);
        // }, 5000);
    </script>

    <script>
        // let contador = 0;

        // function animation() {
        //     contador += 1;
        //     console.log(contador);
        //     loop = requestAnimationFrame(animation);
        // }

        // var loop = requestAnimationFrame(animation);
        // setTimeout(() => {
        //     cancelAnimationFrame(loop);
        // }, 5000);
    </script>

    <hr>

    <h2>Operadores Bitwise</h2>

    <script>
        console.log(Number(113).toString(2));
        console.log(parseInt('1110001', 2))
    </script>

    <hr>

    <h2>DOM e √Årvore de Layout</h2>

    <p>O DOM √© a representa√ß√£o do seu HTML em forma de √°rvore de objetos.</p>

    <p>Cada elemento vira um n√≥ (node).</p>

    <p>Voc√™ n√£o est√° mexendo no HTML diretamente.
        Voc√™ est√° mexendo na √°rvore DOM em mem√≥ria.</p>

    <p>o DOM permite: Selecionar elementos, Alterar conte√∫do,
        Alterar atributos, Criar e remover elementos e Adicionar eventos</p>

    <hr>

    <h2>Factories</h2>

    <p>Uma fun√ß√£o que cria e retorna objetos.</p>

    <script>
        // const Mamifero = function(nome, som) {
        //     return { nome, som};
        // }

        // const cachorro = Mamifero('cachorro', 'auau');
        // console.log(cachorro);
    </script>

    <p>Ela fabrica objetos dinamicamente.</p>

    <p>Isso acontece por causa do shorthand property</p>

    <p>Porque ela fabrica inst√¢ncias sob demanda, igual uma f√°brica.</p>

    <p>Constructor Function (forma antiga)</p>

    <script>
        // function Mamifero(nome, som) {
        //     this.nome = nome;
        //     this.som = som;
        // }
        // const cachorro = new Mamifero('cachorro', 'auau');
    </script>

    <p>Precisa usar new.</p>]

    <p>Factory Function</p>

    <p>Mais simples.
        Sem new.
        Sem this.</p>

    <p>C√≥digo mais limpo <br>
        ‚úî Menos bugs com this<br>
        ‚úî Mais previs√≠vel<br>
        ‚úî Combina muito bem com fun√ß√µes puras</p>

    <p>Factories podem retornar m√©todos tamb√©m:</p>

    <script>
        // function mamifero(nome, som) {
        //     return {
        //         nome,
        //         som,
        //         falar() {
        //             console.log(som);
        //         }
        //     };
        // }

        // const cachorro = mamifero('cachorro', 'auau');
        // cachorro.falar(); // auau
    </script>

    <p>
        Encapsulamento com Factory (parte poderosa) -> Voc√™ pode criar dados privados
    </p>

    <script>
        // function contador() {
        //     let count = 0;

        //     return {
        //         incrementar() {
        //             count++;
        //             console.log(count);
        //         }
        //     };
        // }

        // const c = contador();
        // c.incrementar(); // 1
        // c.incrementar(); // 2
    </script>

    <p>N√£o existe acesso direto a count, Ele fica protegido dentro do escopo</p>

    <p>Isso √© poss√≠vel por causa de closures.</p>

    <hr>

    <h2>Classes</h2>

    <script>
        // class Animal {
        //     constructor(pes) {
        //         this.pes = pes;
        //     }

        //     quantidadePes() {
        //         console.log("Eu tenho " + this.pes + " p√©s/patas.");
        //     }
        // }
        // class Mamifero extends Animal {
        //     constructor(nome, som, pes) {
        //         super(pes);
        //         this.nome = nome;
        //         this.som = som;
        //     }

        //     emitirSom() {
        //         console.log("Esse animal faz " + this.som);
        //     }
        // }

        // const cachorro = new Mamifero('cachorro', 'auau', 4);
        // cachorro.emitirSom();
        // cachorro.quantidadePes();
    </script>

    <p>class no JavaScript √© a√ß√∫car sint√°tico sobre o sistema de prot√≥tipos.</p>

    <p>Ele parece orienta√ß√£o a objeto tradicional (Java, C#),
        mas por baixo continua sendo prototype chain.</p>

    <p>Conceitos importantes que voc√™ j√° est√° usando <br>

        ‚úî Heran√ßa <br>
        ‚úî Encapsulamento b√°sico <br>
        ‚úî Prototype chain <br>
        ‚úî super() <br>
        ‚úî extends <br>

        Isso j√° √© n√≠vel intermedi√°rio real.</p>

</body>

</html>