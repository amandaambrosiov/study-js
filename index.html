<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Curso JS</title>
</head>

<body>
    <h1>32 conceitos que todo desenvolvedor JavaScript deveria saber</h1>

    <h2>Pilha de chamadas (FIFO e LIFO)</h2>

    <p>FIFO = firts in first out - o primeiro que entrou é o primeiro a sair</p>
    <p>LIFO = Last in first out - o ultimo a entrar é o primeiro a sair (JS normalmente é LIFO)</p>

    <script>
    // function funcao1() {
    //     funcao2();
    //     console.log('executou a função 1')
    // }

    // function funcao2() {
    //     funcao3();
    //     console.log('executou a função 2')
    // }

    // function funcao3() {
    //     console.log('executou a função 3')
    // }

    // funcao1();
    </script>

    <hr>

    <h2>Tipos primitivos</h2>
    <p>JavaScript tem 7 tipos primitivos:</p>
    <ul>
        <li>string</li>
        <li>number</li>
        <li>boolean</li>
        <li>undefined</li>
        <li>null</li>
        <li>symbol</li>
        <li>bigint</li>
    </ul>

    <script>
    // console.log(typeof true); //Boolean
    // console.log(typeof Boolean(true)); //Boolean
    // console.log(typeof new Boolean(true)); //Object
    // console.log(typeof (new Boolean(true)).valueOf()); //Boolean
    // console.log(typeof 'Amanda'); //string
    // console.log(typeof 21); //number
    // console.log('Amanda'.length);

    // let doze = new Number(12);
    // let quinze = doze + 3;
    // console.log(quinze);

    // console.log(typeof doze); //object
    // console.log(typeof quinze); //number
    </script>

    <hr>

    <h2>Tipos de valores e tipos de referencias</h2>

    <p>Primitivos → Copiados por VALOR</p>

    <script>
    // let c = 10;
    // let b = c;

    // b = 20;

    // console.log(c); // 10

    // console.log(x, y); //20 10

    // let x =  {valor: 10 };
    // let y = x;
    // x.valor = 20;

    // console.log(x, y); //20 20
    </script>

    <p>Referência → Copiados por REFERÊNCIA</p>
    <small>Objetos, arrays e funções.</small>

    <script>
    // let obj1 = { nome: "Amanda" };
    // let obj2 = obj1;

    // obj2.nome = "Maria";

    // console.log(obj1.nome); // Maria
    </script>
    <hr>

    <h2>COERÇÃO - Implícito, Explicito e chamada de métodos</h2>

    <p>Coerção Implícita - O JS converte automaticamente</p>

    <script>
    // "5" + 1 // "51"
    // "5" - 1 // 4
    </script>

    <p>Coerção Explícita - Você força a conversão</p>

    <script>
    // Number("5")
    // String(10)
    // Boolean(0)
    </script>

    <p>Chamada de métodos</p>

    <p>EX. "amanda".toUpperCase() -> O JS cria temporariamente um objeto String wrapper.</p>

    <script>
    // console.log('5' - 5);
    // console.log('5' + 5);
    // console.log(true + 1);
    // console.log(true + true);
    // console.log([] + {});
    // console.log([] + []);

    // IMPLICITO 
    // console.log(+'5');
    // console.log(5 + '');
    // console.log(123 && 'oi');
    // console.log( null || true);

    // EXPLICITO
    // console.log(Number('50'));
    // console.log(String(50));
    </script>

    <hr>

    <h2>==, === e typeof</h2>

    <p>null == undefined, se for, ele retorna true</p>
    <p>number == string, se for, ele vai converter a string em numero</p>
    <p>boolean == number, se for, ele converte o boolean em numero</p>
    <p>boolean == string, se for, ele converte o string em boolean</p>
    <p>objeto == primitivo, se for, ele converte o objeto em string</p>

    <script>
    // console.log(3 == '3');
    // console.log(3 === 3);
    </script>

    <p>=== é necessário que os valores e tipos sejam iguais</p>

    <hr>

    <h2>Escopo global, de função, de bloco e léxico</h2>


    <p>Escopo global: Variáveis declaradas fora de qualquer função/bloco.</p>
    <p>Escopo de bloco: Criado com function.</p>
    <p>Escopo léxico: A variável é resolvida com base onde foi declarada, não onde foi chamada.</p>

    <p>Escopo léxico define que a visibilidade de variáveis é determinada pelo local físico onde elas são declaradas no
        código-fonte durante a fase de compilação, não onde são chamadas</p>

    <script>
    // var nome = "Amanda";

    // function teste() {
    //     var variavel = "meu nome";
    //     function teste2() {
    //         variavel = "meu nome";
    //     }
    // } //erro 

    // teste();

    // var a = 0;

    // function alterar() {
    //     a = 10;
    // }

    // console.log(a);
    // alterar();
    // console.log(a);
    </script>

    <p>hoisting - ele pega qualquer declação de var ele joga para o começo</p>

    <hr>

    <h2>Expressão e declaração</h2>

    <p>Em programação, expressões são trechos de código que retornam um valor (como 2 + 2), enquanto declarações
        (statements) são instruções que realizam ações ou alteram o estado do programa (como if, for ou int x;). </p>

    <p>Expressões produzem valores e são blocos de construção, já declarações executam comandos, sem necessariamente
        retornar algo.</p>

    <script>
    // console.log(1 + 1);
    // console.log(Math.random() + 5); //expressão

    // function expressao () {
    //     return 1 + 1;
    // }

    // console.log(expressao());

    // var variavel = 20;

    // if (true) {
    //     variavel = 30;
    // }

    // function soma (a) {
    //     return a + 10;
    // }

    // console.log(Math.random());
    </script>

    <hr>

    <h2>IIFE e Namespaces</h2>

    <p>Expressão de função imediatamente invocada</p>

    <script>
    // function alerta() {
    //     alert("Olá mundo!")
    // }

    // const alerta = function() {
    //     alert("Olá mundo!")
    // }

    // alerta();

    // !function() { //Pemite uma função sem o nome
    //     alert("Olá mundo!")
    // }(); //IIFE - função só pode ser executada apenas uma vez

    // (function(){
    //     alert('Olá!');
    // })

    // var dados = (function() {
    //     var contador = 0;
    //     return {
    //         incrementar: function() {
    //             contador = contador + 1;
    //             return contador;
    //         }
    //     }
    // }());

    // console.log(dados.incrementar());
    // console.log(dados.contador);
    </script>

    <p>uma função criada dentro de um objeto é um metodo</p>

    <p>contador esta como uma variavel privada</p>

    <p>namespaces - caso de importação de um biblioteca que ja tenha a função importar, não tem porblema se a função
        estiver no escopo de bloco</p>

    <script src="script.js"></script>
</body>

</html>