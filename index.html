<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Curso JS</title>
</head>

<body>
    <h1>32 conceitos que todo desenvolvedor JavaScript deveria saber</h1>

    <h2>Pilha de chamadas (FIFO e LIFO)</h2>

    <p><strong>FIFO</strong> = firts in first out - o primeiro que entrou √© o primeiro a sair</p>
    <p><strong>LIFO</strong> = Last in first out - o ultimo a entrar √© o primeiro a sair </p>
    <p><strong>(JS normalmente √© LIFO)</strong></p>

    <script>
        // function funcao1() {
        //     funcao2();
        //     console.log('executou a fun√ß√£o 1')
        // }

        // function funcao2() {
        //     funcao3();
        //     console.log('executou a fun√ß√£o 2')
        // }

        // function funcao3() {
        //     console.log('executou a fun√ß√£o 3')
        // }

        // funcao1();
    </script>

    <hr>

    <h2>Tipos primitivos</h2>
    <p>JavaScript tem 7 tipos primitivos:</p>
    <ul>
        <li><strong>string</strong> - texto</li>
        <li><strong>number</strong> - n√∫mero</li>
        <li><strong>boolean</strong> - verdadeiro ou falso</li>
        <li><strong>undefined</strong> - indefinido</li>
        <li><strong>undefined</strong> - nulo</li>
        <li><strong>symbol</strong> - criar valores, fun√ß√µes privadas e at√© mesmo para interceptar um comportamento
            padr√£o de um objeto no JavaScript.</li>
        <li><strong>bigint</strong> - n√∫meros muito grandes</li>
    </ul>

    <script>
        // console.log(typeof true); //Boolean
        // console.log(typeof Boolean(true)); //Boolean
        // console.log(typeof new Boolean(true)); //Object
        // console.log(typeof (new Boolean(true)).valueOf()); //Boolean
        // console.log(typeof 'Amanda'); //string
        // console.log(typeof 21); //number
        // console.log('Amanda'.length);

        // let doze = new Number(12);
        // let quinze = doze + 3;
        // console.log(quinze);

        // console.log(typeof doze); //object
        // console.log(typeof quinze); //number
    </script>

    <hr>

    <h2>Tipos de valores e tipos de refer√™ncias</h2>

    <p>Primitivos ‚Üí Copiados por VALOR</p>

    <p>Cada vari√°vel guarda seu pr√≥prio valor. <br>
        N√£o existe liga√ß√£o entre elas. <br>
        Alterar uma n√£o altera a outra. <br>
        <strong>Isso √© c√≥pia por valor.</strong>
    </p>

    <script>
        // Quando voc√™ faz:
        // let c = 10;
        // let b = c;

        // O que acontece na mem√≥ria ?
        // c ‚Üí 10
        // b ‚Üí 10(c√≥pia independente)

        // b = 20;

        // Depois:

        // b ‚Üí 20
        // c ‚Üí 10 (n√£o muda)

        // console.log(c); // 10
    </script>

    <p>Refer√™ncia ‚Üí Copiados por REFER√äNCIA</p>
    <p>
        Objetos { } <br>
        Arrays [ ] <br>
        Fun√ß√µes function()
    </p>

    <script>
        // console.log(x, y); //20 10

        // let x =  {valor: 10 };
        // let y = x;
        // x.valor = 20;

        // console.log(x, y); //20 20

        // Agora o que acontece na mem√≥ria?

        // x ‚Üí endere√ßo 0x001
        // y ‚Üí endere√ßo 0x001

        // Ambos apontam para o mesmo objeto na mem√≥ria.

        // Quando voc√™ altera:

        // x.valor = 20;

        // Voc√™ n√£o est√° mudando x.
        // Voc√™ est√° mudando o conte√∫do do endere√ßo 0x001.

        // Como y tamb√©m aponta para esse mesmo endere√ßo‚Ä¶

    </script>

    <script>
        // let obj1 = { nome: "Amanda" };
        // let obj2 = obj1;

        // obj2.nome = "Maria";

        // console.log(obj1.nome); // Maria

        // Porque agora voc√™ mudou a refer√™ncia, n√£o o conte√∫do.

        // Antes:

        // obj1 ‚Üí 0x001
        // obj2 ‚Üí 0x001

        // Depois:

        // obj2 ‚Üí 0x002
        // obj1 ‚Üí 0x001

        // S√£o objetos diferentes agora.
    </script>

    <script>
        // Compara√ß√£o direta
        // let a = 10;
        // let b = 10;

        // console.log(a === b); // true

        // Primitivos com mesmo valor ‚Üí iguais.

        // Agora:

        // let obj1 = { nome: "Amanda" };
        // let obj2 = { nome: "Amanda" };

        // console.log(obj1 === obj2); // false

        // Mesmo conte√∫do.
        // Mas refer√™ncias diferentes.
    </script>

    <hr>

    <h2>COER√á√ÉO - Impl√≠cito, Explicito e chamada de m√©todos</h2>

    <p>Coer√ß√£o de tipo √© quando o JavaScript converte automaticamente (ou voc√™ for√ßa) um valor de um tipo para outro.
    </p>

    <p>Coer√ß√£o Impl√≠cita (autom√°tica) - O JavaScript decide converter sozinho.</p>

    <p>Quando existe + e um dos lados √© string ‚Üí o JS converte tudo para string.</p>

    <p>O operador - s√≥ funciona com n√∫mero.</p>

    <script>
        // "5" + 1 // "51"
        // "5" - 1 // 4
    </script>

    <script>
        // console.log('5' - 5); // 0
        // console.log('5' + 5); // "55"
        // console.log(true + 1); // 2
        // console.log(true + true); // 2
    </script>

    <script>
        // console.log([] + {}); //"[object Object]"
    </script>

    <p>
        O que acontece? <br>
        [] vira "" <br>
        {} vira "[object Object]" <br>
        String + string ‚Üí concatena
    </p>

    <p>Operadores que for√ßam coer√ß√£o impl√≠cita</p>

    <p>Unary Plus</p>

    <p>Equivalente a: Number('5')</p>

    <p>String vazia</p>

    <p>console.log(5 + ''); // "5"</p>

    <p>Operadores l√≥gicos</p>

    <p>console.log(123 && 'oi'); // "oi"</p>

    <p>
        && retorna o √∫ltimo valor verdadeiro. <br>
        123 √© truthy <br>
        Ent√£o retorna 'oi'
    </p>

    <p>console.log(null || true); // true</p>

    <p>null √© falsy.
        Ent√£o retorna o pr√≥ximo valor.</p>

    <script>
        // console.log(+'5'); // 5
    </script>

    <p>Coer√ß√£o Expl√≠cita (voc√™ controla) - Aqui voc√™ decide converter.</p>

    <p>Converter para n√∫mero</p>

    <script>
        // Number('50') // 50
        // parseInt('50')
        // parseFloat('50.5')
    </script>

    <p>Converter para string</p>

    <script>
        // String(50)
        //     (50).toString()
    </script>

    <script>
        // Number("5")
        // String(10)
        // Boolean(0)
    </script>

    <p>Converter para boolean</p>

    <script>
        // Boolean(0) // false
        // Boolean(1) // true
        // Boolean("") // false
        // Boolean("Amanda") // true
    </script>

    <p>Existem apenas 7 valores falsy:</p>

    <p>false <br>
        0 <br>
        -0 <br>
        "" <br>
        null <br>
        undefined <br>
        NaN</p>

    <p>Chamada de m√©todos</p>

    <p>EX. "amanda".toUpperCase() -> O JS cria temporariamente um objeto String wrapper.</p>
    <p>JS cria objeto tempor√°rio</p>

    <script>
        // let nome = "Amanda";
        // nome.length;

        // new String("amanda")
    </script>

    <script>
        // console.log('5' - 5);
        // console.log('5' + 5);
        // console.log(true + 1);
        // console.log(true + true);
        // console.log([] + {});
        // console.log([] + []);

        // IMPLICITO
        // console.log(+'5');
        // console.log(5 + '');
        // console.log(123 && 'oi');
        // console.log( null || true);

        // EXPLICITO
        // console.log(Number('50'));
        // console.log(String(50));
    </script>

    <hr>

    <h2>==, === e typeof</h2>

    <p>== (igualdade abstrata)</p>

    <p>O == permite coer√ß√£o de tipo antes de comparar.</p>

    <p>null == undefined, se for, ele retorna true</p>
    <p>number == string, se for, ele vai converter a string em numero</p>
    <p>boolean == number, se for, ele converte o boolean em numero</p>
    <p>boolean == string, se for, ele converte o string em boolean</p>
    <p><small>
            <p>Na verdade o JS converte boolean em n√∫mero primeiro, depois compara.</p>
        </small></p>
    <p>objeto == primitivo, se for, ele converte o objeto em string</p>



    <script>
        // null == undefined // true
        // null === undefined // false

        // 3 == '3' // true

        // true == 1 // true
        // false == 0 // true

        // true == "1"

        // [1] == 1 // true
        // // [1].toString() ‚Üí "1"
        // // Number("1") ‚Üí 1

        // [] == false // true
    </script>

    <script>
        // console.log(3 == '3');
        // console.log(3 === 3);
    </script>

    <p>=== (igualdade estrita)</p>

    <p>Aqui N√ÉO existe coer√ß√£o.</p>

    <p>Ele compara:
        Tipo e
        Valor</p>

    <script>
        // 3 === '3' // false
        // 3 === 3   // true
    </script>

    <p>typeof - Usado para descobrir o tipo.</p>

    <script>
        // typeof 10        // "number"
        // typeof "Amanda"  // "string"
        // typeof true      // "boolean"
        // typeof undefined // "undefined"
        // typeof Symbol()  // "symbol"
        // typeof 10n       // "bigint"
    </script>

    <p>Isso √© um BUG hist√≥rico do JavaScript. null n√£o √© objeto.</p>

    <script>
        typeof null // "object"
    </script>

    <script>
        // typeof {}          // "object"
        // typeof []          // "object"
        // typeof function () { } // "function"
    </script>

    <hr>

    <h2>Escopo global, de fun√ß√£o, de bloco e l√©xico</h2>

    <p>Escopo global: Vari√°veis declaradas fora de qualquer fun√ß√£o/bloco.</p>
    <p>Problema: Podem ser sobrescritas, Poluem o escopo global e Em sistemas grandes isso vira caos</p>
    <p>Escopo de bloco/fun√ß√£o: Criado com function.</p>
    <p>
        Function cria escopo de fun√ß√£o <br>
        Bloco ({}) cria escopo de bloco quando usamos let e const
    </p>

    <p>Escopo l√©xico: A vari√°vel √© resolvida com base onde foi declarada, n√£o onde foi chamada.</p>
    <script>
        // let nome = "Amanda";

        // function externa() {
        //     let sobrenome = "Ambrosio";

        //     function interna() {
        //         console.log(nome);
        //         console.log(sobrenome);
        //     }

        //     interna();
        // }

        // externa();
    </script>

    <script>
        // var nome = "Amanda";

        // function teste() {
        //     var variavel = "meu nome";
        //     function teste2() {
        //         variavel = "meu nome";
        //     }
        // } //erro

        // teste();

        // var a = 0;

        // function alterar() {
        //     a = 10;
        // }

        // console.log(a);
        // alterar();
        // console.log(a);
    </script>

    <p>
        <strong>O que √© Hoisting?</strong> <br>
        Durante a fase de cria√ß√£o do c√≥digo, o JavaScript: <br>
        Move declara√ß√µes para o topo do escopo <br>
        N√ÉO move inicializa√ß√µes
    </p>

    <script>
        // console.log(a);
        // var a = 10; //undefined
    </script>

    <p>Porque existe algo chamado:

        üëâ Temporal Dead Zone (TDZ)</p>

    <p>A vari√°vel existe, mas n√£o pode ser acessada antes da declara√ß√£o.</p>

    <script>
        // console.log(b);
        // let b = 20; //ReferenceError
    </script>

    <p>Conceito -> O que faz</p>

    <p>Global -> Vari√°vel acess√≠vel em todo c√≥digo</p>

    <p>Fun√ß√£o -> Criado por function</p>

    <p>Bloco -> Criado por {} com let/const</p>

    <p>L√©xico -> Resolvido onde foi declarado</p>

    <p>Hoisting -> Declara√ß√µes s√£o movidas para o topo</p>

    <hr>

    <h2>Express√£o e declara√ß√£o</h2>

    <p>Express√£o vs Declara√ß√£o impacta: <br>
        Hoisting <br>
        Fun√ß√µes <br>
        Arrow functions <br>
        IIFE <br>
        Callbacks <br>
        React <br>
        Programa√ß√£o funcional</p>

    <p><strong>O que √© uma Express√£o?</strong></p>

    <p>Express√£o √© qualquer coisa que produz um valor.</p>

    <script>
        // 2 + 2
        // "a" + "b"
        // true
        // Math.random()
    </script>

    <p><strong>O que √© uma Declara√ß√£o (Statement)?</strong></p>

    <p>√â uma instru√ß√£o que executa algo.</p>

    <script>
        // if (true) { }
        // for (...) { }
        // while (...) { }
        // var x = 10;
        // function teste() { }
    </script>

    <p>Voc√™ n√£o pode fazer:</p>

    <script>
        // let x = if (true) { 10 };
    </script>

    <p>Em programa√ß√£o, express√µes s√£o trechos de c√≥digo que retornam um valor (como 2 + 2), enquanto declara√ß√µes
        (statements) s√£o instru√ß√µes que realizam a√ß√µes ou alteram o estado do programa (como if, for ou int x;). </p>

    <p>Express√µes produzem valores e s√£o blocos de constru√ß√£o, j√° declara√ß√µes executam comandos, sem necessariamente
        retornar algo.</p>

    <script>
        // console.log(1 + 1);
        // console.log(Math.random() + 5); //express√£o

        // function expressao () {
        //     return 1 + 1;
        // }

        // console.log(expressao());

        // var variavel = 20;

        // if (true) {
        //     variavel = 30;
        // }

        // function soma (a) {
        //     return a + 10;
        // }

        // console.log(Math.random());
    </script>

    <hr>

    <h2>IIFE e Namespaces</h2>

    <p>Express√£o de fun√ß√£o imediatamente invocada</p>

    <script>
        // function alerta() {
        //     alert("Ol√° mundo!")
        // }

        // const alerta = function() {
        //     alert("Ol√° mundo!")
        // }

        // alerta();

        // !function() { //Pemite uma fun√ß√£o sem o nome
        //     alert("Ol√° mundo!")
        // }(); //IIFE - fun√ß√£o s√≥ pode ser executada apenas uma vez

        // (function(){
        //     alert('Ol√°!');
        // })

        // var dados = (function() {
        //     var contador = 0;
        //     return {
        //         incrementar: function() {
        //             contador = contador + 1;
        //             return contador;
        //         }
        //     }
        // }());

        // console.log(dados.incrementar());
        // console.log(dados.contador);
    </script>

    <p>uma fun√ß√£o criada dentro de um objeto √© um metodo</p>

    <p>contador esta como uma variavel privada</p>

    <p>namespaces - caso de importa√ß√£o de um biblioteca que ja tenha a fun√ß√£o importar, n√£o tem porblema se a fun√ß√£o
        estiver no escopo de bloco</p>

    <script src="script.js"></script>
</body>

</html>